var _ = require('lodash');
var fs = require('fs');
var util = require('util');

import { ConfigurationManager } from '../config/ConfigurationManager';
import { ResultsManager } from '../results/ResultsManager';
import { ParametersManager } from '../parameters/ParametersManager';
import { BenchmarksManager } from '../benchmarks/BenchmarksManager';
import { EnvironmentManager } from '../environment/EnvironmentManager';
import { MeasurementType } from '../config/MeasurementType';
import { Formatter } from '../../utilities/Formatter';

export class ReportGenerator {
    private static readonly SeparatorLine = "***************************************************************\r\n";
    private static readonly NewLine = "\r\n";
    
    private _configuration: ConfigurationManager;
    private _results: ResultsManager;
    private _parameters: ParametersManager;
    private _benchmarks: BenchmarksManager;
    private _environment: EnvironmentManager;
    
    public constructor(configuration: ConfigurationManager, 
        results: ResultsManager, parameters: ParametersManager, 
        benchmarks: BenchmarksManager, environment: EnvironmentManager) {
            
        this._configuration = configuration;
        this._results = results;
        this._parameters = parameters;
        this._benchmarks = benchmarks;
        this._environment = environment;
    }
    
    public generate(): string {
        let output = '';
        output += this.generateHeader();
        output += this.generateBenchmarkList();

        if (this._results.all.length > 1)
            output += this.generateMultipleResults();
        else
            output += this.generateSingleResult();
        
        output += this.generateSystemInfo();
        output += this.generateSystemBenchmark();
        output += this.generateParameters();
        return output;
    }

    public saveToFile(fileName: string): void {
        let output = this.generate();
        fs.writeFileSync(fileName, output);
    }

    private generateHeader(): string {
        let output = '';
        output += ReportGenerator.SeparatorLine;
        output += ReportGenerator.NewLine;
        output += "             P E R F O R M A N C E    R E P O R T";
        output += ReportGenerator.NewLine;
        output += ReportGenerator.NewLine;
        output += "                 Generated by Pip.Benchmark";
        output += ReportGenerator.NewLine;
        output += util.format("                   at %s, %s", 
            Formatter.formatDate(new Date()), Formatter.formatTime(new Date()));
        output += ReportGenerator.NewLine;
        output += ReportGenerator.SeparatorLine;
        output += ReportGenerator.NewLine;
        return output;
    }

    private generateBenchmarkList(): string {
        let output = '';
        output += "Executed Benchmarks:";
        output += ReportGenerator.NewLine;
        let index = 0;
        _.each(this._benchmarks.selected, (benchmark) => {
            index++;
            output += util.format("  %d. %s.%s [%d%%]",
                index, benchmark.suite.name, benchmark.name, benchmark.proportion
            );
            output += ReportGenerator.NewLine;
        });
        output += ReportGenerator.NewLine;
        return output;
    }

    private generateMultipleResults(): string {
        let output = '';
        output += "Benchmarking Results:";
        output += ReportGenerator.NewLine;

        let results = this._results.all;
        let resultTable: string[][] = [];
        for (let index = 0; index < results.length + 2; index++) {
            resultTable.push(new Array('', '', '', ''));
        }

        // Fill column headers
        resultTable[0][0] = "Benchmark";
        resultTable[0][1] = "Performance (tps)";
        resultTable[0][2] = "CPU Load (%)";
        resultTable[0][3] = "Memory Usage (Mb)";

        let columnSizes: number[] = [ 9, 17, 12, 17 ];

        for (let index = 0; index < results.length; index++) {
            resultTable[index + 1][0] = results[index].benchmarks[0].fullName;
            columnSizes[0] = Math.max(resultTable[index + 1][0].length, columnSizes[0]);

            resultTable[index + 1][1] = Formatter.formatNumber(
            	results[index].performanceMeasurement.averageValue);
            columnSizes[1] = Math.max(resultTable[index + 1][1].length, columnSizes[1]);

            resultTable[index + 1][2] = Formatter.formatNumber(
            	results[index].cpuLoadMeasurement.averageValue);
            columnSizes[2] = Math.max(resultTable[index + 1][2].length, columnSizes[2]);

            resultTable[index + 1][3] = Formatter.formatNumber(
            	results[index].memoryUsageMeasurement.averageValue);
            columnSizes[3] = Math.max(resultTable[index + 1][3].length, columnSizes[3]);
        }

        for (let rowIndex = 0; rowIndex < results.length + 1; rowIndex++) {
            // Draw upper line
            if (rowIndex == 0) {
                output += '+';
                for (let columnIndex = 0; columnIndex < 4; columnIndex++) {
                    output += Formatter.padRight("", columnSizes[columnIndex], "-");
                    output += '+';
                }
                output += ReportGenerator.NewLine;
            }

            // Draw content
            output += '|';
            output += Formatter.padRight(resultTable[rowIndex][0], columnSizes[0], " ");
            output += '|';
            output += Formatter.padLeft(resultTable[rowIndex][1], columnSizes[1], " ");
            output += '|';
            output += Formatter.padLeft(resultTable[rowIndex][2], columnSizes[2], " ");
            output += '|';
            output += Formatter.padLeft(resultTable[rowIndex][3], columnSizes[3], " ");
            output += '|';
            output += ReportGenerator.NewLine;

            // Draw bottom line
            output += '+';
            for (let columnIndex = 0; columnIndex < 4; columnIndex++) {
                output += Formatter.padRight("", columnSizes[columnIndex], "-");
                output += '+';
            }
            output += ReportGenerator.NewLine;
        }

        output += ReportGenerator.NewLine;
        return output;
    }

    private generateSingleResult(): string {
        let output = '';

        if (this._results.all.length == 0)
            return output;

        let result = this._results.all[0];

        output += "Benchmarking Results:";
        output += ReportGenerator.NewLine;
        if (this._configuration.measurementType == MeasurementType.Peak) {
            output += "  Measurement Type: Peak Performance";
        } else {
            output += util.format("  Measurement Type: Nominal Performance at %d tps",
                this._configuration.nominalRate);
        }
        output += ReportGenerator.NewLine;

        let startTime = new Date(result.startTime);
        output += util.format("  Start Time:   %s", Formatter.formatTime(startTime));
        output += ReportGenerator.NewLine;
        let endTime = new Date(result.startTime + result.elapsedTime);
        output += util.format("  End Time:     %s", Formatter.formatTime(endTime));
        output += ReportGenerator.NewLine;
        let elapsedTime = result.elapsedTime;
        output += util.format("  Elapsed Time: %s", Formatter.formatTimeSpan(elapsedTime));
        output += ReportGenerator.NewLine;
        output += util.format("  Min Performance (tps):     %d",
            Formatter.formatNumber(result.performanceMeasurement.minValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Average Performance (tps): %d",
            Formatter.formatNumber(result.performanceMeasurement.averageValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Max Performance (tps):     %d",
            Formatter.formatNumber(result.performanceMeasurement.maxValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Min CPU Load (%%):          %d",
            Formatter.formatNumber(result.cpuLoadMeasurement.minValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Average CPU Load (%%):      %d",
            Formatter.formatNumber(result.cpuLoadMeasurement.averageValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Max CPU Load (%%):          %d",
            Formatter.formatNumber(result.cpuLoadMeasurement.maxValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Min Memory Usage (Mb):     %d",
            Formatter.formatNumber(result.memoryUsageMeasurement.minValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Average Memory Usage (Mb): %d",
            Formatter.formatNumber(result.memoryUsageMeasurement.averageValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Max Memory Usage (Mb):     %d",
            Formatter.formatNumber(result.memoryUsageMeasurement.maxValue));
        output += ReportGenerator.NewLine;
        output += ReportGenerator.NewLine;

        return output;
    }

    private generateSystemInfo(): string {
        let output = '';
        output += "System Information:";
        output += ReportGenerator.NewLine;
        for (let prop in this._environment.systemInfo) {
            let value = this._environment.systemInfo[prop];
            output += util.format("  %s: %s", prop, value);
            output += ReportGenerator.NewLine;
        }
        output += ReportGenerator.NewLine;
        return output;
    }

    private generateSystemBenchmark(): string {
        let output = '';
        output += "System Benchmarking:";
        output += ReportGenerator.NewLine;
        output += util.format("  CPU Performance (MFLOP/s): %d",
            Formatter.formatNumber(this._environment.cpuMeasurement));
        output += ReportGenerator.NewLine;
        output += util.format("  Video Performance (GOP/s): %d",
            Formatter.formatNumber(this._environment.videoMeasurement));
        output += ReportGenerator.NewLine;
        output += util.format("  Disk Performance (MB/s):   %d",
            Formatter.formatNumber(this._environment.diskMeasurement));
        output += ReportGenerator.NewLine;
        output += ReportGenerator.NewLine;
        return output;
    }

    private generateParameters(): string {
        let output = '';
        output += "Parameters:";
        output += ReportGenerator.NewLine;
        _.each(this._parameters.all, (parameter) => {
            output += util.format("  %s=%s", parameter.name, parameter.value);
            output += ReportGenerator.NewLine;
        });
        output += ReportGenerator.NewLine;
        return output;
    }

}
