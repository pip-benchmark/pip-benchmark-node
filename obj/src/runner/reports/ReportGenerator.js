"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
let _ = require('lodash');
let fs = require('fs');
let util = require('util');
const MeasurementType_1 = require("../config/MeasurementType");
const Formatter_1 = require("../../utilities/Formatter");
class ReportGenerator {
    constructor(configuration, results, parameters, benchmarks, environment) {
        this._configuration = configuration;
        this._results = results;
        this._parameters = parameters;
        this._benchmarks = benchmarks;
        this._environment = environment;
    }
    generate() {
        let output = '';
        output += this.generateHeader();
        output += this.generateBenchmarkList();
        if (this._results.all.length > 1)
            output += this.generateMultipleResults();
        else
            output += this.generateSingleResult();
        output += this.generateSystemInfo();
        output += this.generateSystemBenchmark();
        output += this.generateParameters();
        return output;
    }
    saveToFile(fileName) {
        let output = this.generate();
        fs.writeFileSync(fileName, output);
    }
    generateHeader() {
        let output = '';
        output += ReportGenerator.SeparatorLine;
        output += ReportGenerator.NewLine;
        output += "             P E R F O R M A N C E    R E P O R T";
        output += ReportGenerator.NewLine;
        output += ReportGenerator.NewLine;
        output += "                 Generated by Pip.Benchmark";
        output += ReportGenerator.NewLine;
        output += util.format("                   at %s, %s", Formatter_1.Formatter.formatDate(new Date()), Formatter_1.Formatter.formatTime(new Date()));
        output += ReportGenerator.NewLine;
        output += ReportGenerator.SeparatorLine;
        output += ReportGenerator.NewLine;
        return output;
    }
    generateBenchmarkList() {
        let output = '';
        output += "Executed Benchmarks:";
        output += ReportGenerator.NewLine;
        let index = 0;
        for (let benchmark of this._benchmarks.isSelected) {
            index++;
            output += util.format("  %d. %s.%s [%d%%]", index, benchmark.suite.name, benchmark.name, benchmark.proportion);
            output += ReportGenerator.NewLine;
        }
        output += ReportGenerator.NewLine;
        return output;
    }
    generateMultipleResults() {
        let output = '';
        output += "Benchmarking Results:";
        output += ReportGenerator.NewLine;
        let results = this._results.all;
        let resultTable = [];
        for (let index = 0; index < results.length + 2; index++) {
            resultTable.push(new Array('', '', '', ''));
        }
        // Fill column headers
        resultTable[0][0] = "Benchmark";
        resultTable[0][1] = "Performance (tps)";
        resultTable[0][2] = "CPU Load (%)";
        resultTable[0][3] = "Memory Usage (Mb)";
        let columnSizes = [9, 17, 12, 17];
        for (let index = 0; index < results.length; index++) {
            resultTable[index + 1][0] = results[index].benchmarks[0].fullName;
            columnSizes[0] = Math.max(resultTable[index + 1][0].length, columnSizes[0]);
            resultTable[index + 1][1] = Formatter_1.Formatter.formatNumber(results[index].performanceMeasurement.averageValue);
            columnSizes[1] = Math.max(resultTable[index + 1][1].length, columnSizes[1]);
            resultTable[index + 1][2] = Formatter_1.Formatter.formatNumber(results[index].cpuLoadMeasurement.averageValue);
            columnSizes[2] = Math.max(resultTable[index + 1][2].length, columnSizes[2]);
            resultTable[index + 1][3] = Formatter_1.Formatter.formatNumber(results[index].memoryUsageMeasurement.averageValue);
            columnSizes[3] = Math.max(resultTable[index + 1][3].length, columnSizes[3]);
        }
        for (let rowIndex = 0; rowIndex < results.length + 1; rowIndex++) {
            // Draw upper line
            if (rowIndex == 0) {
                output += '+';
                for (let columnIndex = 0; columnIndex < 4; columnIndex++) {
                    output += Formatter_1.Formatter.padRight("", columnSizes[columnIndex], "-");
                    output += '+';
                }
                output += ReportGenerator.NewLine;
            }
            // Draw content
            output += '|';
            output += Formatter_1.Formatter.padRight(resultTable[rowIndex][0], columnSizes[0], " ");
            output += '|';
            output += Formatter_1.Formatter.padLeft(resultTable[rowIndex][1], columnSizes[1], " ");
            output += '|';
            output += Formatter_1.Formatter.padLeft(resultTable[rowIndex][2], columnSizes[2], " ");
            output += '|';
            output += Formatter_1.Formatter.padLeft(resultTable[rowIndex][3], columnSizes[3], " ");
            output += '|';
            output += ReportGenerator.NewLine;
            // Draw bottom line
            output += '+';
            for (let columnIndex = 0; columnIndex < 4; columnIndex++) {
                output += Formatter_1.Formatter.padRight("", columnSizes[columnIndex], "-");
                output += '+';
            }
            output += ReportGenerator.NewLine;
        }
        output += ReportGenerator.NewLine;
        return output;
    }
    generateSingleResult() {
        let output = '';
        if (this._results.all.length == 0)
            return output;
        let result = this._results.all[0];
        output += "Benchmarking Results:";
        output += ReportGenerator.NewLine;
        if (this._configuration.measurementType == MeasurementType_1.MeasurementType.Peak) {
            output += "  Measurement Type: Peak Performance";
        }
        else {
            output += util.format("  Measurement Type: Nominal Performance at %d tps", this._configuration.nominalRate);
        }
        output += ReportGenerator.NewLine;
        let startTime = new Date(result.startTime);
        output += util.format("  Start Time:   %s", Formatter_1.Formatter.formatTime(startTime));
        output += ReportGenerator.NewLine;
        let endTime = new Date(result.startTime + result.elapsedTime);
        output += util.format("  End Time:     %s", Formatter_1.Formatter.formatTime(endTime));
        output += ReportGenerator.NewLine;
        let elapsedTime = result.elapsedTime;
        output += util.format("  Elapsed Time: %s", Formatter_1.Formatter.formatTimeSpan(elapsedTime));
        output += ReportGenerator.NewLine;
        output += util.format("  Min Performance (tps):     %d", Formatter_1.Formatter.formatNumber(result.performanceMeasurement.minValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Average Performance (tps): %d", Formatter_1.Formatter.formatNumber(result.performanceMeasurement.averageValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Max Performance (tps):     %d", Formatter_1.Formatter.formatNumber(result.performanceMeasurement.maxValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Min CPU Load (%%):          %d", Formatter_1.Formatter.formatNumber(result.cpuLoadMeasurement.minValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Average CPU Load (%%):      %d", Formatter_1.Formatter.formatNumber(result.cpuLoadMeasurement.averageValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Max CPU Load (%%):          %d", Formatter_1.Formatter.formatNumber(result.cpuLoadMeasurement.maxValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Min Memory Usage (Mb):     %d", Formatter_1.Formatter.formatNumber(result.memoryUsageMeasurement.minValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Average Memory Usage (Mb): %d", Formatter_1.Formatter.formatNumber(result.memoryUsageMeasurement.averageValue));
        output += ReportGenerator.NewLine;
        output += util.format("  Max Memory Usage (Mb):     %d", Formatter_1.Formatter.formatNumber(result.memoryUsageMeasurement.maxValue));
        output += ReportGenerator.NewLine;
        output += ReportGenerator.NewLine;
        return output;
    }
    generateSystemInfo() {
        let output = '';
        output += "System Information:";
        output += ReportGenerator.NewLine;
        for (let prop in this._environment.systemInfo) {
            let value = this._environment.systemInfo[prop];
            output += util.format("  %s: %s", prop, value);
            output += ReportGenerator.NewLine;
        }
        output += ReportGenerator.NewLine;
        return output;
    }
    generateSystemBenchmark() {
        let output = '';
        output += "System Benchmarking:";
        output += ReportGenerator.NewLine;
        output += util.format("  CPU Performance (MFLOP/s): %d", Formatter_1.Formatter.formatNumber(this._environment.cpuMeasurement));
        output += ReportGenerator.NewLine;
        output += util.format("  Video Performance (GOP/s): %d", Formatter_1.Formatter.formatNumber(this._environment.videoMeasurement));
        output += ReportGenerator.NewLine;
        output += util.format("  Disk Performance (MB/s):   %d", Formatter_1.Formatter.formatNumber(this._environment.diskMeasurement));
        output += ReportGenerator.NewLine;
        output += ReportGenerator.NewLine;
        return output;
    }
    generateParameters() {
        let output = '';
        output += "Parameters:";
        output += ReportGenerator.NewLine;
        for (let parameter of this._parameters.all) {
            output += util.format("  %s=%s", parameter.name, parameter.value);
            output += ReportGenerator.NewLine;
        }
        output += ReportGenerator.NewLine;
        return output;
    }
}
ReportGenerator.SeparatorLine = "***************************************************************\r\n";
ReportGenerator.NewLine = "\r\n";
exports.ReportGenerator = ReportGenerator;
//# sourceMappingURL=ReportGenerator.js.map